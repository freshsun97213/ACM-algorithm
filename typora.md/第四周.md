# 第四周

### 7-31 贪心 与 高精度

注意点：

1、每个区间里面的前缀零要省去，如果不是按照一位一位或者十位十位进位的话，以100一进位就需要进行前缀零的增加

2、开头的数组的零要舍去，当没有任何一个有意义数字出现的时候，需要将这个0舍去







## 8-01  大小根堆 和 二叉树前后中序遍历

### 大小根堆 时间复杂度（）

​	大小根堆，不完全的去符合升序和降序的标准,意思也就是说，它并不是一定能根据 ，二叉树的前序、后序、中序遍历就可以直接写出 ，有序的数列的 他只能通过将优先级最高的输出 然后在使其有序。

​	所以，之于大小根堆的单点最值操作的效率是非常高的，但是对于区间操作来说，大小根堆是完全实现不了的，也并非无法实现，只是其实现方式和效率，冗杂并且效率低下，时间复杂度相当的高。

==手写小根堆==

````c ++
#include <iostream>
#include <map>
#include <vector>

#define ll long long
#define de(x) cerr << #x << " " << x << endl;
using namespace std;

ll len; // 二叉树-----元素个数 大小根堆本质上是一个树
/*
struct node{
  int w = 0;
  node *l = NULL,*r = NULL;
}nod;
*/
const int N = 1e6 + 10;
int tree[N];
void push(int x) {
  len++;
  tree[len] = x;
  int i = len;
  // de(tree[len]);
  // de(len);
  //  de(tree[1]);
  while (tree[i] < tree[i / 2] && i > 1) {
    swap(tree[i], tree[i / 2]);
    i /= 2; // 这里除去二 是整除一定几率可以表明的是 小根堆
    // 是在先填入左边 再填入右边的
    // 所以大小根堆删除不了指定的第几小的数字
  }
  //  de(tree[1]);
}
void pop() {
  //   de(tree[1]);
  tree[1] = tree[len];
  // de(tree[1]);
  // de(tree[len]);
  len--;
  // de(len);
  // de(tree[len]);
  int i = 1;
  while (i * 2 <= len) {
    int s = i * 2;
    if (s < len && tree[s + 1] < tree[s]) {
      s++;
    }
    if (tree[s] < tree[i]) {
      swap(tree[i], tree[s]);
      i = s;
    } else {
      break;
    }
    // 这个大小根堆，不需要完全的去符合升序和降序的标准
    //
    // if (tree[i * 2] < tree[i]) {
    //   swap(tree[i * 2], tree[i]);
    //   i *= 2;
    // } else {
    //   if (tree[i] > tree[i + 1]) {
    //     swap(tree[i + 1], tree[i]);
    //     i = i + 1;
    //   } else {
    //     return;
    //   }
    // }
  }
}

int main() {
  int n;
  cin >> n;
  while (n--) {
    int op;
    cin >> op;
    if (op == 1) {
      int x;
      cin >> x;
      push(x);
    } else if (op == 2) {
      cout << tree[1] << endl;
    } else {
      pop();
    }
  }

  return 0;
}

````

==priority queue==

```c++
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

int main() {
  vector<int> a;
  priority_queue<int, vector<int>, greater<int>> A;
  int n;
  cin >> n;
  while (n--) {
    int op;
    cin >> op;
    if (op == 1) {
      int x;
      cin >> x;
      A.push(x);
    } else if (op == 2) {
      cout << A.top() << endl;
    } else {
      A.pop();
    }
  }
  return 0;
}

```





#  问题遗留2

问题主要在于，这一块pop代码，

````c++
void pop() {
  //   de(tree[1]);
  tree[1] = tree[len];
  // de(tree[1]);
  // de(tree[len]);
  len--;
  // de(len);
  // de(tree[len]);
  int i = 1;
  while (i * 2 <= len) {
    int s = i * 2;
    if (s < len && tree[s + 1] < tree[s]) {
      s++;
    }
    if (tree[s] < tree[i]) {
      swap(tree[i], tree[s]);
      i = s;
    } else {
      break;
    }
    // 这个大小根堆，不需要完全的去符合升序和降序的标准
    // 意思也就是说，它并不是一定能根据 ，二叉树的前序、后序、中序遍历就可以直接写出 ，有序的数列的
    // 他只能通过将优先级最高的输出 然后在使其有序。  
    // if (tree[i * 2] < tree[i]) {
    //   swap(tree[i * 2], tree[i]);
    //   i *= 2;
    // } else {
    //   if (tree[i] > tree[i + 1]) {
    //     swap(tree[i + 1], tree[i]);
    //     i = i + 1;
    //   } else {
    //     return;
    //   }
    // }
  }
}

````



### 二叉树如门



[二叉树及其遍历](https://zhuanlan.zhihu.com/p/244927128)





### 语法知识

#### 优先队列（priority_queue）

```c++
#include<queue>
void priority_queue<typename ,container,functional>; //默认是大根堆，也就是top元素是最大的
// typename 类型名称
// container 容器名称
// functional 优先级排序的函数 可以根据重载符opterator 来写仿函数


//××仿函数排序的书写
```



##### 基本操作：

>push():
>
>emplace():[c++11]
>
>pop():
>
>top():
>
>empty():
>
>size():