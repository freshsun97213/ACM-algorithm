# 第五周



## 8-7周一

### 牛客多校 8-7 C题目位运算





### 正常上课 并查集

#### 语法  好玩的函数 $iota（）$ 和 $atoi（）$

[$ioat atoi$](https://blog.csdn.net/lemonxiaoxiao/article/details/108659831);



````c++
#include<numeric>
tmplate<class ForwardIt first,class T>
void ioat(ForwardIt first,ForwardIt last , T value);// since c++11 until c++ 20

tmplate<class ForwardIt first,class T>
constexpr void ioat(ForwardIt first,ForwardIt last , T value);// since c++ 20
//函数的作用是给容器赋值，这个值只能够是递增的去赋值，不可以递减赋值
//并且该容器 需要可以重载++ 运算符号
//该函数的要点在于，ForwardIt 不可以用反向指针例如， rend()/crend() 和 rbegin() crbegin();
````

#### 并查集 总结

-   分帮（根节点数 ）（例题：POJ 2524 ubiquitous religions 无处不在的宗教）
    -   这个我觉得和下面那样都是可以一边并查集，一边计算
-   找朋友（是否认识 或者 是否在同一组别） （洛谷例题：亲戚P2078 和 相亲P1551 和 百米跑P2256）
    -   是否是同一组别
    -   该组别有多少人 ： ==（我总觉得这样类型的题目是可以有所优化的，不能够在并查集之后在进行一次遍历）==
-   是否全部联通（例题：洛谷 修复公路P1111，可以归结在分帮类别里面，它可以看作，最后是否只有一个共同的根节点的特殊情况）

##### 第一类 分帮 找根节点数

````c++
#include<iostream>         /*例题 ：  POJ2524     */
#include<numeric>                                   
#include<vector>                                    
using namespace std;                                
vector<int>mp;                                      
int find(int x){                                    
	if( x == mp[x] ){return x;}                     
    else{return mp[x] = find(mp[x]);}               
}                                                   
int main(){                                         
	int n,m,t = 0;                                   
	while(cin >> n >> m ){                   
		t ++;                                 
		if(n == m && m== 0){return 0;}             
		mp.resize(n+1);                        
		//std::iota(mp.begin(),mp.end(),0);                
		for(int i = 0;i <= n;i++){mp[i] = i;}            
		int k = n;                                
		for(int i = 0;i < m;i ++){                   
			int a,b;                            
			cin >> a >> b;                               
			if(find(a) == find(b) ){continue;}                
			else{                              
				mp[find(a)] = mp[find(b)];             
				k --;                         //关键在于k，k--代表每有一条变相互链接上，那就代表根节点会减少一个
			}                                 //当两个人在于统一组别的时候，再次相连（重边）或者自己和自己相连
		}                                     //这两种情况是不能够算入到 k--的条件里面的
		cout <<"Case "<< t <<": "<<k <<endl;  //所以如果find a == find b的话 k不进行-- 操作
	}                                                
	return 0;                                   
}                                                  
````



``````c++
#include<iostream> // 这道题目对于笔者来说更具有，记忆性，可能是第一次想到，所以会记忆深刻一点
#include<algorithm>
using namespace std;
const int N =1e5+10;
struct valley{
	int t,a,to;
	friend bool operator <(const valley &a,const valley &b){return a.t<b.t;};
}v[N];
int e[N];
int find(int x){
	if(e[x] == x){return x;}
	else {return e[x] = find(e[x]);} // e[x] = find(e[x]);这一步骤进行了路径优化，将所有的点都指向了根节点
};
int main(){
	int n,m;
	cin >> n >>m;
	for(int i = 1;i <= n;i ++){e[i] = i;}
	//表示是否连通的情况下,我们可以通过不重复的边来表示是否全部连通,或者说是
	//不成环路的情况下,对于其进行edge的相加 
	for(int i = 0;i < m;i ++){cin >> v[i].a >>v[i].to >> v[i].t;} 
	sort(v,v+m); 
	int edge = 0,i = 0,t = -1;
	for(i = 0;i < m;i ++){                                                                 
    if(find(v[i].a) != find(v[i].to)){//这一步判断一定要加上find函数，因为这里是结构体输入，并不是e[i]并不能代表其根节点
			edge ++;		
			e[find(v[i].a)] = e[find(v[i].to)];//这一步也是为了将从根节点到其他所有的的父节点进行更新
		}else{continue;}
		if(edge == n -1){
			t = v[i].t;
			break;
		}
	} 
	cout << ((edge == n - 1 ) ? t : -1) << '\n';
} 
``````



##### 第二类找朋友

比较简单可以不去管，就直接查看根节点是否相同就好

不过 除了上述的路径优化，还有一种按秩优化的方法，是根据层数大小来优化的，将小树接在大树里面，这样可以保证搜索的效率是O（logN）;之后在细说



==遗留== 按秩优化
